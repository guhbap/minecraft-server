package mode

import (
	"bytes"
	"fmt"
	"math/rand"

	"github.com/Tnze/go-mc/nbt"
	"github.com/golangmc/minecraft-server/impl/conn"
)

type Heightmap struct {
	MotionBlocking []int64 `nbt:"MOTION_BLOCKING"`
	WorldSurface   []int64 `nbt:"WORLD_SURFACE"`
}
type Root struct {
	Heightmap Heightmap `nbt:""`
}

func CreateChunk(x, z int) []byte {
	buf := conn.ConnBuffer{}
	buf.PushI32(int32(x))
	buf.PushI32(int32(z))

	baseHM := []int64{}
	for range 37 {
		baseHM = append(baseHM, 0)
	}

	root := Root{
		Heightmap: Heightmap{
			MotionBlocking: baseHM,
			WorldSurface:   baseHM,
		},
	}
	var nbtBuf bytes.Buffer
	enc := nbt.NewEncoder(&nbtBuf)
	enc.NetworkFormat(true)
	if err := enc.Encode(root.Heightmap, ""); err != nil {
		panic(err)
	}
	buf.PushUAS(nbtBuf.Bytes(), false)
	buf.PushVrI(2244)
	// buf.PushByt(1)
	// buf.PushByt(0)
	buf.PushI16(256)
	buf.PushByt(4)
	pal := Palette{
		Blocks: []byte{0, 9, 14},
	}

	pal.Push(&buf)
	chunk := NewChunkSection()
	// chunk.Blocks[0][0][0] = 0x01
	// var air = byte(0b0000)
	var grass = byte(0b0001)
	// var cobble = byte(0b0010)
	chunk.SetBlock(2, 3, 5, grass)
	chunk.SetBlock(2, 3, 4, grass)
	chunk.SetBlock(2, 3, 3, grass)
	chunk.SetBlock(3, 3, 2, grass)
	chunk.SetBlock(4, 3, 2, grass)
	chunk.SetBlock(5, 3, 2, grass)
	chunk.SetBlock(6, 3, 3, grass)
	chunk.SetBlock(7, 3, 3, grass)
	chunk.SetBlock(8, 3, 3, grass)
	chunk.SetBlock(9, 3, 3, grass)
	chunk.SetBlock(10, 3, 2, grass)
	chunk.SetBlock(11, 3, 2, grass)
	chunk.SetBlock(12, 3, 2, grass)
	chunk.SetBlock(13, 3, 3, grass)

	chunk.SetBlock(13, 3, 4, grass)
	chunk.SetBlock(13, 3, 5, grass)

	chunk.SetBlock(12, 3, 6, grass)
	chunk.SetBlock(11, 3, 6, grass)
	chunk.SetBlock(10, 3, 5, grass)

	chunk.SetBlock(5, 3, 5, grass)
	chunk.SetBlock(6, 3, 6, grass)
	chunk.SetBlock(4, 3, 6, grass)
	chunk.SetBlock(3, 3, 6, grass)
	chunk.SetBlock(8, 3, 14, grass)

	chunk.SetBlock(6, 3, 5, grass)
	chunk.SetBlock(6, 3, 6, grass)
	chunk.SetBlock(6, 3, 7, grass)
	chunk.SetBlock(6, 3, 8, grass)
	chunk.SetBlock(6, 3, 9, grass)
	chunk.SetBlock(6, 3, 10, grass)
	chunk.SetBlock(6, 3, 11, grass)
	chunk.SetBlock(6, 3, 12, grass)
	chunk.SetBlock(6, 3, 13, grass)
	chunk.SetBlock(9, 3, 5, grass)
	chunk.SetBlock(9, 3, 6, grass)
	chunk.SetBlock(9, 3, 7, grass)
	chunk.SetBlock(9, 3, 8, grass)
	chunk.SetBlock(9, 3, 9, grass)
	chunk.SetBlock(9, 3, 10, grass)
	chunk.SetBlock(9, 3, 11, grass)
	chunk.SetBlock(9, 3, 12, grass)
	chunk.SetBlock(9, 3, 13, grass)
	chunk.SetBlock(7, 3, 14, grass)

	chunk.Push(&buf)
	buf.PushByt(0)
	// buf.PushByt(57) // биом the void
	buf.PushByt(byte(rand.Intn(10) + 50)) // биом the void
	pal = Palette{
		Blocks: []byte{},
	}
	pal.Push(&buf)
	buf.PushUAS(randomBiomeData, false)
	skyLight := NewSkyLight()
	buf.PushByt(3)
	skyLight.Push(&buf)
	skyLight.Push(&buf)
	skyLight.Push(&buf)
	buf.PushByt(0)
	return buf.UAS()
}

func init() {
	fmt.Println("randomBiomeData len", len(randomBiomeData))
	for i := 0; i < len(randomBiomeData); i++ {
		// randomBiomeData[i] = 0x00
	}
	fmt.Println()
	res, pos, msg := deepCompareByteArrays(realData, realData)
	fmt.Println("res", res, "pos", pos, "msg", msg)
	buf := conn.ConnBuffer{}

	fmt.Println("buf", buf.HexString())
	// ChunkData.Push(buf, nil)

	res, pos, msg = deepCompareByteArrays(myBytes, buf.UAS())
	fmt.Println("res", res, "pos", pos, "msg", msg)
	fmt.Println("chunkDecode done")
	// os.Exit(0)
}

func deepCompareByteArrays(test, real []byte) (bool, int, string) {
	for i := 0; i < len(real); i++ {
		if test[i] != real[i] {
			return false, i, fmt.Sprintf("test[%d] = 0x%x, real[%d] = 0x%x (0x%x, 0x%x, 0x%x)", i, test[i], i, real[i], test[i], test[i+1], test[i+2])
		}
	}
	return true, 0, ""
}

type Palette struct {
	Blocks []byte
}

func (p *Palette) Push(buf *conn.ConnBuffer) {
	buf.PushByt(byte(len(p.Blocks)))
	buf.PushUAS(p.Blocks, false)
}

type ChunkSection struct {
	Blocks [][][]byte
}

func (p *ChunkSection) GetBlock(x, y, z int) byte {
	return p.Blocks[y][x][7-z]
}

func (p *ChunkSection) SetBlock(x, y, z int, block byte) {
	x = 15 - x
	realX := x / 2
	isHigh := x%2 == 1 // старшая или младшая половина байта

	if isHigh {
		p.Blocks[y][z][realX] &= 0xF0 // 11110000
		p.Blocks[y][z][realX] |= block & 0x0F
	} else {
		p.Blocks[y][z][realX] &= 0x0F // 00001111
		p.Blocks[y][z][realX] |= (block & 0x0F) << 4
	}

}

func NewChunkSection() *ChunkSection {
	chs := &ChunkSection{}
	chs.Blocks = make([][][]byte, 16)
	for i := 0; i < 16; i++ {
		chs.Blocks[i] = make([][]byte, 16)
		for j := 0; j < 16; j++ {
			chs.Blocks[i][j] = make([]byte, 8)
		}
	}
	return chs
}
func (chs *ChunkSection) Push(buf *conn.ConnBuffer) {
	buf.PushVrI(256)
	for i := 0; i < 16; i++ {
		for j := 0; j < 16; j++ {
			for k := 0; k < 8; k++ {
				buf.PushByt(chs.Blocks[i][j][k])
			}
		}
	}
}

type SkyLight struct {
	Light []byte
}

func (p *SkyLight) Push(buf *conn.ConnBuffer) {
	buf.PushUAS(p.Light, true)
}

func NewSkyLight() *SkyLight {
	skyLight := &SkyLight{}
	skyLight.Light = make([]byte, 2048)
	for i := 0; i < 2048; i++ {
		skyLight.Light[i] = 0xff
	}
	return skyLight
}

var randomBiomeData = []byte{
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x39, 0x00,
	0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x07, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x07,
	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x00, 0x00, 0x00,
	// 0x00, 0x00, 0x39, 0x00,

	// 0x00, 0x01, 0x00, 0x00,
	// 0x00, 0x00, 0x00, 0x00,

	// 0x00, 0x07, 0x00, 0x00,
	// 0x01, 0x07, 0x00, 0x00,
	// 0x00, 0x00, 0x00, 0x00,
	// 0x07,
}
